\section {Standardsoftware vs Individualsoftware}
\setauthor{Philipp Füreder}

In der heutigen digitalisierten Welt ist Software nicht mehr wegzudenken,
für den Erfolg von Unternehmen oder auch für den privaten Gebrauch.
Für diese Diplomarbeit unterscheiden wir zwischen zwei Hauptarten von Software, 
die von Unternehmen genutzt werden: 
\textbf{Standardsoftware} und 
\textbf{Individualsoftware}.
Nun wollen wir diese beiden Softwaretypen in einem direkten 
Vergleich gegenüberstellen, um ihre jeweiligen Vor- und Nachteile zu zeigen.

\subsection*{Standardsoftware}

Standardsoftware bietet Vorteile, die sie für viele Unternehmen und Einzelpersonen 
zu einer attraktiven Wahl machen. Einer der Hauptvorteile ist die Kosteneffizienz: 
Da die Entwicklungskosten auf eine Vielzahl von Kunden verteilt werden, sind die 
Anschaffungskosten in der Regel geringer als bei einer individuell entwickelten Lösung. 
Ein weiterer Pluspunkt ist die schnelle Implementierung. Da die Software bereits entwickelt ist, 
kann sie in der Regel schnell installiert und in Betrieb genommen werden, 
wodurch Zeit und Ressourcen gespart werden. Zudem profitieren Benutzer von einer 
breiten Community und einem umfangreichen Support, was sowohl die Problembehebung 
als auch die Weiterentwicklung erleichtert. Hinzu kommt die breite Verfügbarkeit von 
Schulungsmaterialien und Kursen für gängige Standardsoftware. 
Diese Ressourcen erleichtern die Einarbeitung und ermöglichen es den Benutzern, 
das volle Potenzial der Software auszuschöpfen.

Ein Nachteil von Standardsoftware besteht darin, dass sie nicht immer genau 
den individuellen Anforderungen eines Unternehmens gerecht wird. 
Es könnte vorkommen, dass spezifische Funktionen fehlen oder die Software 
nicht optimal auf die Arbeitsprozesse des Unternehmens zugeschnitten ist.

\newpage
\subsection*{Individualsoftware}

Individualsoftware bietet Unternehmen die einzigartige Möglichkeit, eine Softwarelösung 
zu erhalten, die vollständig an ihre speziellen Bedürfnisse und Anforderungen angepasst ist. 
Diese Anpassungsfähigkeit erlaubt nicht nur effizientere Arbeitsprozesse, 
sondern schafft auch Raum für Flexibilität und Skalierbarkeit. 
Da die Software im Laufe der Zeit sich ändernden Unternehmensbedürfnissen angepasst werden kann, 
bleibt sie stets ein dynamisches und anpassungsfähiges Werkzeug. 
Zudem kann Individualsoftware langfristig kosteneffizient sein, da keine laufenden 
Lizenzgebühren für nicht benötigte Funktionen anfallen. 
So vereint Individualsoftware in sich die Vorteile von vollständiger Anpassung, 
Flexibilität, Skalierbarkeit und wirtschaftlicher Effizienz.

Trotz der vielen Vorteile kommt Individualsoftware oft mit einem wesentlichen Nachteil: 
den hohen Anschaffungskosten. Die Entwicklung einer maßgeschneiderten Softwarelösung 
erfordert in der Regel eine erhebliche Investition in Zeit und Ressourcen. 
Diese initialen Kosten können beträchtlich sein und stellen daher besonders für 
kleinere Unternehmen oder Organisationen mit begrenztem Budget eine große Hürde dar. 
Daher ist es wichtig, diese Investition sorgfältig abzuwägen und sie in den Kontext der 
erwarteten langfristigen Vorteile und Kostenersparnisse zu setzen.

\newpage
\section{Problemverständnis}

Standardsoftware ist häufig so konzipiert, dass sie den Anforderungen einer breiten 
Zielgruppe gerecht wird, was jedoch oft dazu führt, dass spezifische Funktionen fehlen, 
die für einzelne Unternehmen oder Organisationen von Bedeutung sein könnten. 
Eine individuelle Anpassung dieser Standardsoftware an die Bedürfnisse jedes einzelnen 
Kunden wäre zwar theoretisch möglich, brächte jedoch erhebliche Nachteile mit sich. 
Insbesondere würde die Software dadurch zunehmend komplizierter und 
schwieriger zu pflegen werden. Jede spezielle Anpassung könnte zu Konflikten mit 
anderen Funktionen führen oder zukünftige Updates erschweren. Die Software würde an 
Übersichtlichkeit verlieren und die Fehleranfälligkeit könnte steigen. 
Darüber hinaus wäre es für die Softwareanbieter schwierig, allen individuellen 
Anforderungen zu folgen und gleichzeitig eine stabile, einheitliche 
Version des Produkts zu erhalten. Daher wird bei Standardsoftware oft ein Kompromiss 
angestrebt, der zwar viele, aber nicht alle Bedürfnisse abdeckt, um die Software so 
einfach und wartbar wie möglich zu halten.\\

Der Fokus auf vorhandene Ressourcen ist ein entscheidendes Argument gegen die Implementierung 
kundenspezifischer Funktionen in einer Softwarelösung für jedes einzelne Unternehmen. 
Softwareentwicklung umfasst nicht nur die Programmierung selbst, sondern auch die Planung, 
das Design, die Qualitätssicherung und die Wartung. Unternehmen haben in der Regel begrenzte 
Entwicklungsressourcen, sowohl in Bezug auf die Anzahl der Entwickler als auch die Zeit und 
das Budget. Diese Ressourcen müssen sorgfältig auf die Entwicklung von Funktionen konzentriert 
werden, die den größten Mehrwert für die Mehrheit der Kunden bieten. Das Hinzufügen von 
kundenspezifischen Funktionen würde diese begrenzten Ressourcen auf Projekte lenken, 
die nur für eine kleine Anzahl von Nutzern relevant sind, und damit den Wert der Software 
für die allgemeine Kundschaft potenziell verringern. Infolgedessen müssen Unternehmen 
Prioritäten setzen und ihre Entwicklungsressourcen auf Aktivitäten fokussieren, 
die das Produkt als Ganzes verbessern und den meisten Kunden zugutekommen.

\newpage
\section{Lösungsansatz: Scripting}
\setauthor{Philipp Füreder}

Ein vielversprechender Ansatz zur Lösung von fehlenden Funktionen in einer Software besteht darin 
Scripting zu nutzen. Dadurch erhalten Benutzer/innen die Möglichkeit, eigene Scripts zu erstellen, 
um spezifische Funktionen innerhalb der Software auszuführen. Diese Scripts werden 
zur Laufzeit in die Anwendung geladen.

\subsection*{Allgemeines zu Scripting}

Scripting ermöglicht es individuelle Lösungen zu erstellen, 
die den eigenen Anforderungen gerecht werden. 
Dies erweitert den Nutzen der Software, ohne auf offizielle Updates oder neue Versionen 
warten zu müssen oder sogar eine eigene Software entwickeln zu müssen.

Eine Skriptsprache wird vor allem verwendet, um Websites und Webanwendungen zu automatisieren. 
Wenn man ein Skript schreibt, baut man kein völlig neues Programm von Grund auf. 
Stattdessen verknüpft man bestehende Teile eines Programms miteinander. 
Dann führt das Programm dieses Skript aus.

Ein zentraler Aspekt dieser Diplomarbeit war die Untersuchung der Rolle des Scripting 
bei der dynamischen Anpassung von .NET-Anwendungen. Der Einsatz von Skriptsprachen ermöglicht es, 
fehlende oder zusätzliche Funktionen zur Laufzeit in eine Anwendung zu integrieren. 
Im Rahmen unserer Arbeit wurde verschiedenen Skriptsprachen experimentiert, um deren 
Eignung für die Integration in .NET-Anwendungen zu bewerten. Insbesondere wurde erforscht, 
wie Skripte nahtlos in die .NET-Anwendungen eingebettet und ausgeführt werden können, um die 
Flexibilität und Erweiterbarkeit der Anwendungen zu erhöhen. 

\newpage

\subsection*{Vorteile}

\begin{itemize}
    \item \textbf{Schnelle Entwicklung:} Skriptsprachen werden interpretiert, 
    wodurch Code rasch entwickelt und getestet werden kann. 
    Dies ermöglicht ein einfaches Ausprobieren neuer Ideen und die zügige 
    Erzielung von Ergebnissen, was Skriptsprachen besonders für interaktive 
    Programmieransätze geeignet macht.
    \item \textbf{Benutzerfreundlichkeit:} Skriptsprachen zeichnen sich durch ihre 
    Benutzerfreundlichkeit aus, wobei der Fokus auf der simplen und intuitiven 
    Gestaltung gängiger Aufgaben liegt. Diese Eigenschaft eignet sich perfekt für Anfänger 
    sowie für Aufgaben, die keine umfangreiche Rechenleistung erfordern.
    \item \textbf{Flexibles Verhalten:} Häufig weisen Skriptsprachen eine dynamische 
    Typisierung auf, die es ermöglicht, dass der Typ einer Variablen während der 
    Laufzeit verändert werden kann. Dies vereinfacht die Erstellung flexiblen und 
    anpassungsfähigen Codes sowie den Umgang mit Daten in vielfältigen Formaten.

\end{itemize}

\subsection*{Nachteile}

\begin{itemize}
    \item Der größte Nachteil von Skriptsprachen ist, dass sie langsamer sind als 
    andere Programmiersprachen. Das liegt daran, dass in Skriptsprachen jedes 
    Statement nacheinander während der Ausführung gelesen und verarbeitet wird.
    \item Wenn während der Ausführung des Skripts ein Fehler entdeckt wird, 
    stoppt der Interpreter die Ausführung, bis dieser korrigiert wird.
\end{itemize}

\newpage

\subsection*{Levels von Scripting}

In Microsoft Excel gibt es die Möglichkeit sich wiederholende Aufgaben mithilfe 
von Office Scripts zu automatisieren.
\\
Man kann auf zwei Arten ein neues Office-Skript erstellen:
\begin{itemize}
    \item Man kann seine Handlungen mithilfe des Actionrecorders aufnehmen. 
    Diese Methode eignet sich besonders gut, wenn man sich wiederholende 
    Schritte in dem Dokument merken möchte. Dazu sind keine Programmierkenntnisse 
    oder ähnliches erforderlich. Die Aufgezeichneten Skripte können 
    abgespeichert und verändert werden.
    \item Die zweite Möglichkeit ist, dass Office-Skript selbst mithilfe 
    von TypeScript zu schreiben.
\end{itemize}

Folgendes Office-Skript Beispiel gibt den Wert von der Zelle A1 auf der Konsole aus:

\begin{lstlisting} [language=Python,caption=Office-Skript,label=lst:impl:foo]
    function main(workbook: ExcelScript.Workbook) {
  // Get the current worksheet.
  let selectedSheet = workbook.getActiveWorksheet();

  // Get the value of cell A1.
  let range = selectedSheet.getRange("A1");
  
  // Print the value of A1.
  console.log(range.getValue());
}
\end{lstlisting}

\newpage

\section{Alternativen}
\setauthor{Philipp Füreder}

\subsection*{Microsoft Power Automate}

Power Automate ist eine cloudbasierte Plattform, die es Anwender/innen unkompliziert ermöglicht, 
Workflows zu erstellen. Diese Arbeitsabläufe automatisieren zeitaufwändige 
geschäftliche Aufgaben und Prozesse, indem sie Anwendungen und Dienste verbinden.\\

Logik-Apps (ein Service von Azure), 
präsentiert vergleichbare Eigenschaften wie Power Automate. Zusätzlich dazu 
bietet es weitere Leistungsmerkmale, darunter die nahtlose Einbindung in den 
Azure Resource Manager, das Azure-Portal, PowerShell, die xPlat-CLI, Visual Studio und 
diverse weitere Verbindungselemente.\\

Mit folgenden Dienstleistungen können Power Automate verbunden werden:

\begin{itemize}
    \item Sharepoint
    \item Dynamics 365
    \item OneDrive
    \item Google Drive
    \item Google Sheets
    \item und noch einige mehr
\end{itemize}

Power Automate ist außerdem plattformübergreifend und kann auf allen modernen Geräten und Browsern
ausgeführt werden. Zur Verwendung ist nur ein Webbrowser und eine E-Mail-Adresse erforderlich.

\newpage
\subsection*{Dynamische Modulsysteme}

Ein Ansatz, der oft angewandt wird, um Anwendungen oder Systeme zu konstruieren, 
ist die Nutzung eines dynamischen Modulsystems. Diese Methode ermöglicht die Erstellung 
von Applikationen durch den Zusammenbau wiederverwendbarer Einzelmodule. 
Diese Herangehensweise erleichtert die Entwicklung komplexer Systeme, ohne dass jedes 
Mal von Grund auf ein völlig neues System erstellt werden muss. Ein weiterer Nutzen besteht darin, 
dass verschiedene Anwendungen oder Systeme auf diese Weise miteinander verknüpft werden können.
Modulsysteme werden oft in der Softwareentwicklung, Webentwicklung, 
Datenbanken und Systemadministration verwendet.\\

Beispiele für Modulsysteme:

Webanwendung
\begin{itemize}
    \item Javascript-Frameworks wie React und Angular
\end{itemize}

Desktop- und Serveranwendung
\begin{itemize}
    \item .NET und Java
\end{itemize}

Erstellung und Verwaltung von Datenbanken
\begin{itemize}
    \item PostgreSQL und MongoDB
\end{itemize}

Verwaltung von Netzwerken und Systemen
\begin{itemize}
    \item Puppet und Chef
\end{itemize}

\newpage
\subsection*{Microservices}

Microservices stellen einen Ansatz in der Softwareentwicklung dar. Er basiert darauf, 
dass Software aus einer Vielzahl kleiner, eigenständiger Dienste besteht. 
Diese Dienste interagieren miteinander über klar definierte Schnittstellen.
Die Architektur von Microservices trägt dazu bei, Skalierbarkeit zu erleichtern und die 
Zeitspanne für die Entwicklung von Anwendungen zu verkürzen. 
Dies ermöglicht eine schnellere Umsetzung von Innovationen und beschleunigt die Einführung 
neuer Funktionen auf dem Markt.

\subsubsection*{Eigenschaften von Microservices}

\textbf{Eigenständigkeit:}\\
In einer Architektur von Mikroservices besteht die Möglichkeit, jeden einzelnen Komponentenservice 
unabhängig zu entwickeln, bereitzustellen, zu betreiben und zu skalieren. 
Hierbei hat die Veränderung eines Services keine Auswirkungen auf die Funktionalität anderer Services. 
Es ist nicht erforderlich, dass Services Code oder Implementierungen miteinander teilen. 
Die Interaktion zwischen den verschiedenen Komponenten erfolgt ausschließlich 
über eindeutig definierte APIs.\\

\textbf{Spezialisierung:}\\
Jeder einzelne Service ist darauf ausgerichtet, eine spezifische Gruppe von 
Problemstellungen zu lösen. Sollte man im Laufe der Zeit zusätzlichen Code zu einem 
solchen Dienst hinzufügen, und dadurch der Service zu komplex wird, besteht die Option, 
diesen in kleinere Services aufzuteilen.

\newpage
\subsection*{Dynamisches Laden von Assemblies}

Das .NET-Framework biete die Möglichkeit, Assembly-Dateien zur Laufzeit zu laden. 
Dies ermöglicht es, neue Funktionen in Form von Klassen und Methoden hinzuzufügen. 
Assemblies stellen die Grundbausteine von .NET-Anwendungen dar und treten in Form 
von ausführbaren Dateien (.exe) oder Dynamic Link Library-Dateien (.dll) auf.\\

Folgender Beispielcode dient dazu, eine Assembly mit der Bezeichnung "example.exe" innerhalb 
der aktuellen Anwendungsdomäne zu laden. Anschließend wird ein Typ mit dem Namen "Example" 
aus dieser Assembly abgerufen. Auf diesen abgerufenen Typ wird die Methode "MethodA" ausgeführt.\\

\begin{lstlisting} [language={[Sharp]C},caption=Assembly,label=lst:impl:foo]
    using System;
    using System.Reflection;
    
    public class Asmload0
    {
        public static void Main()
        {
            // Use the file name to load the assembly into the current
            // application domain.
            Assembly a = Assembly.Load("example");
            // Get the type to use.
            Type myType = a.GetType("Example");
            // Get the method to call.
            MethodInfo myMethod = myType.GetMethod("MethodA");
            // Create an instance.
            object obj = Activator.CreateInstance(myType);
            // Execute the method.
            myMethod.Invoke(obj, null);
        }
    }
\end{lstlisting}

\newpage
\subsection*{Plugins}

Durch die Nutzung von Plugins eröffnet sich die Option, individuelle Funktionen 
zu entwickeln und anschließend in die Anwendung einzubauen. 
Dies eröffnet ein Fenster für eine dynamische Erweiterbarkeit, ohne auf die Implementierung 
von Skriptcode zurückgreifen zu müssen. Diese Methode gewährt eine flexible 
Herangehensweise an die Erweiterung und Anpassung von Funktionalitäten, während 
gleichzeitig die Sauberkeit der Gesamtlösung erhalten bleibt.

\subsubsection*{Plugin Framework for .NET Core}

Mit Plugin Frameworks für .NET Core wird jegliches Element zu einem Plugin. Das Plugin 
Framework stellt eine erstklassige Plattform für Plugins in .NET Core-Anwendungen dar, was 
sowohl ASP.NET Core, Blazor, WPF, Windows Forms als auch Konsolenanwendungen miteinschließt. 
Diese Plattform zeichnet sich durch eine geringe Systembelastung aus und bietet eine nahtlose 
Einbindungsmöglichkeit. Es kann verschiedene Plugin-Kataloge unterstützen, 
darunter .NET-Assemblies, NuGet-Pakete sowie Roslyn-Skripte. 
Die Flexibilität dieses Frameworks ermöglicht es, eine breite Palette an Anwendungsfällen 
zu bedienen und die Erweiterungsfunktionalität auf mehreren Ebenen zu steigern.

\textbf{Features:}
\begin{itemize}
    \item Einfache Integration in eine neue oder bestehende .NET Core-Anwendung
    \item Automatische Verwaltung von Abhängigkeiten
    \item Behandlung von plattformspezifischen Laufzeit-DLLs bei Verwendung von Nuget-packages
\end{itemize}

\newpage
\section{Beschreibung über die Durchführung der Diplomarbeit}
\setauthor{Philipp Füreder}



\newpage
\section{Machbarkeitsnachweis (Beispielanwendung)}
\setauthor{Philipp Füreder}